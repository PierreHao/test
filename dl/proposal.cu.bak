#include "layer.h"
#include "cuda_settings.h"

#define NMS_BLOCK_SIZE (sizeof(unsigned long long) * 8)

__device__
inline real iou_kernel(const real* const A, const real* const B)
{
#ifdef PASS
  const real left = max(a[0], b[0]);
  const real right = min(a[2], b[2]);
  const real top = max(a[1], b[1]);
  const real bottom = min(a[3], b[3]);
  const real width = max(right - left + 1, 0.0f);
  const real height = max(bottom - top + 1, 0.0f);
  const real interS = width * height;
  const real Sa = (a[2] - a[0] + 1) * (a[3] - a[1] + 1);
  const real Sb = (b[2] - b[0] + 1) * (b[3] - b[1] + 1);
  return interS / (Sa + Sb - interS);
#else
  // overlapped region (= box)
  const real x1 = max(A[0], B[0]);
  const real x2 = min(A[2], B[2]);
  const real y1 = max(A[1], B[1]);
  const real y2 = min(A[3], B[3]);

  // intersection area
  const real width = max(0.0f,  x2 - x1 + 1);
  const real height = max(0.0f,  y2 - y1 + 1);
  const real area = width * height;

  // area of A, B
  const real A_area = (A[2] - A[0] + 1) * (A[3] - A[1] + 1);
  const real B_area = (B[2] - B[0] + 1) * (B[3] - B[1] + 1);

  // IoU
  return area / (A_area + B_area - area);
#endif
}

__global__
void nms_kernel(const int n_boxes, const real nms_thresh,
                const real* const dev_boxes,
                unsigned long long* const dev_mask)
{
#ifdef PASS
  const int row_size =
        min(n_boxes - blockIdx.y * blockDim.x, blockDim.x);
  const int col_size =
        min(n_boxes - blockIdx.x * blockDim.x, blockDim.x);

  __shared__ real block_boxes[NMS_BLOCK_SIZE * 5];
  if (threadIdx.x < col_size) {
    const int index = blockIdx.x * blockDim.x + threadIdx.x;
    block_boxes[threadIdx.x * 5 + 0] = dev_boxes[index * 5 + 0];
    block_boxes[threadIdx.x * 5 + 1] = dev_boxes[index * 5 + 1];
    block_boxes[threadIdx.x * 5 + 2] = dev_boxes[index * 5 + 2];
    block_boxes[threadIdx.x * 5 + 3] = dev_boxes[index * 5 + 3];
    block_boxes[threadIdx.x * 5 + 4] = dev_boxes[index * 5 + 4];
  }
  __syncthreads();

  if (threadIdx.x < row_size) {
    const int cur_box_idx = blockIdx.y * blockDim.x + threadIdx.x;
    const real* const cur_box = dev_boxes + cur_box_idx * 5;
    unsigned long long t = 0;
    const int start = (blockIdx.x == blockIdx.y) ? threadIdx.x + 1 : 0;
    for (int i = start; i < col_size; ++i) {
      if (iou_kernel(cur_box, block_boxes + i * 5) > nms_thresh) {
        t |= 1ULL << i;
      }
    }
    const int col_blocks = DIV_THEN_CEIL(n_boxes, blockDim.x);
    dev_mask[cur_box_idx * col_blocks + blockIdx.x] = t;
  }
#else
  // block region
  //   j = j_start + { 0, ..., dj_end - 1 }
  //   i = i_start + { 0, ..., di_end - 1 }
  const int i_start = blockIdx.x * NMS_BLOCK_SIZE;
  const int di_end = MIN(n_boxes - i_start,  (int)(NMS_BLOCK_SIZE));
  const int j_start = blockIdx.y * NMS_BLOCK_SIZE;
  const int dj_end = MIN(n_boxes - j_start,  (int)(NMS_BLOCK_SIZE));

  // copy all i-th boxes to GPU cache
  //   i = i_start + { 0, ..., di_end - 1 }
  __shared__ real boxes_i[NMS_BLOCK_SIZE * 5];
  {
    const int di = threadIdx.x;
    if (di < di_end) {
      boxes_i[di * 5 + 0] = dev_boxes[(i_start + di) * 5 + 0];
      boxes_i[di * 5 + 1] = dev_boxes[(i_start + di) * 5 + 1];
      boxes_i[di * 5 + 2] = dev_boxes[(i_start + di) * 5 + 2];
      boxes_i[di * 5 + 3] = dev_boxes[(i_start + di) * 5 + 3];
      boxes_i[di * 5 + 4] = dev_boxes[(i_start + di) * 5 + 4];
    }
  }
  __syncthreads();

  // given j = j_start + dj,
  //   check whether box i is significantly overlapped with box j
  //   (i.e., IoU(box j, box i) > threshold)
  //   for all i = i_start + { 0, ..., di_end - 1 } except for i == j
  {
    const int dj = threadIdx.x;
    if (dj < dj_end) {
      // box j
      const real* const box_j = dev_boxes + (j_start + dj) * 5;

      // mask for significant overlap
      //   if IoU(box j, box i) > threshold,  di-th bit = 1
      unsigned long long mask_j = 0;

      // check for all i = i_start + { 0, ..., di_end - 1 }
      // except for i == j
      const int di_start = (i_start == j_start) ? (dj + 1) : 0;
      for (int di = di_start; di < di_end; ++di) {
        // box i
        const real* const box_i = boxes_i + di * 5;

        // if IoU(box j, box i) > threshold,  di-th bit = 1
        if (iou_kernel(box_j, box_i) > nms_thresh) {
          mask_j |= 1ULL << di;
        }
      }

      // mask: "num_boxes x num_blocks" array
      //   for mask[j][bi], "di-th bit = 1" means:
      //     box j is significantly overlapped with box i = i_start + di,
      //     where i_start = bi * block_size
      {
        const int num_blocks = DIV_THEN_CEIL(n_boxes, NMS_BLOCK_SIZE);
        const int bi = blockIdx.x;
        dev_mask[(j_start + dj) * num_blocks + bi] = mask_j;
      }
    } // endif dj < dj_end
  }
#endif
}

#include <stdio.h>

void _nms_gpu(int* const keep_out, int* const num_out,
              const real* const boxes_host,
              const int boxes_num, const int boxes_dim,
              const real nms_thresh)
{
  real* boxes_dev = NULL;
  unsigned long long* mask_dev = NULL;

  const int threads_per_block = NMS_BLOCK_SIZE;
  const int col_blocks = DIV_THEN_CEIL(boxes_num, threads_per_block);

  CUDA_CHECK(cudaMalloc(&boxes_dev, boxes_num * boxes_dim * sizeof(real)));
  CUDA_CHECK(cudaMemcpy(boxes_dev,
                        boxes_host,
                        boxes_num * boxes_dim * sizeof(real),
                        cudaMemcpyHostToDevice));

  CUDA_CHECK(cudaMalloc(&mask_dev, boxes_num * col_blocks * sizeof(unsigned long long)));

  const dim3 blocks(col_blocks, col_blocks);
  const dim3 threads(threads_per_block);
  nms_kernel<<<blocks, threads>>>(boxes_num, nms_thresh, boxes_dev, mask_dev);

  unsigned long long* const mask_host
      = (unsigned long long*)malloc(boxes_num * col_blocks * sizeof(unsigned long long));
  CUDA_CHECK(cudaMemcpy(mask_host,
                        mask_dev,
                        sizeof(unsigned long long) * boxes_num * col_blocks,
                        cudaMemcpyDeviceToHost));

  CUDA_CHECK(cudaFree(boxes_dev));
  CUDA_CHECK(cudaFree(mask_dev));

  for (int i = 0; i < 20; ++i) {
    for (int j = 0; j < col_blocks; ++j)
      printf("%lld ", mask_host[i * col_blocks + j]);
    printf("\n");
  }

  unsigned long long* const remv
      = (unsigned long long*)malloc(col_blocks * sizeof(unsigned long long));
  memset(remv, 0, sizeof(unsigned long long) * col_blocks);

  int num_to_keep = 0;
  for (int i = 0; i < boxes_num; ++i) {
    const int nblock = i / threads_per_block;
    const int inblock = i % threads_per_block;

    if (!(remv[nblock] & (1ULL << inblock))) {
      keep_out[num_to_keep++] = i;
      unsigned long long* p = mask_host + i * col_blocks;
      for (int j = nblock; j < col_blocks; ++j) {
        remv[j] |= p[j];
      }
    }
  }
  *num_out = num_to_keep;

  free(mask_host);
  free(remv);
}

typedef struct BoundingBox_
{
  real x1, y1, x2, y2;
  real score;
} BoundingBox;

int transform_box(BoundingBox* const box,
                  const real dx, const real dy,
                  const real dw, const real dh,
                  const real im_w, const real im_h,
                  const real min_w, const real min_h)
{
  const real w = box->x2 - box->x1 + 1.0f;
  const real h = box->y2 - box->y1 + 1.0f;
  const real ctr_x = box->x1 + 0.5f * w;
  const real ctr_y = box->y1 + 0.5f * h;

  const real pred_ctr_x = dx * w + ctr_x;
  const real pred_ctr_y = dy * h + ctr_y;
  const real pred_w = exp(dw) * w;
  const real pred_h = exp(dh) * h;

  box->x1 = pred_ctr_x - 0.5f * pred_w;
  box->y1 = pred_ctr_y - 0.5f * pred_h;
  box->x2 = pred_ctr_x + 0.5f * pred_w;
  box->y2 = pred_ctr_y + 0.5f * pred_h;

  box->x1 = max(min(box->x1, im_w - 1.0f), 0.0f);
  box->y1 = max(min(box->y1, im_h - 1.0f), 0.0f);
  box->x2 = max(min(box->x2, im_w - 1.0f), 0.0f);
  box->y2 = max(min(box->y2, im_h - 1.0f), 0.0f);

  const real box_w = box->x2 - box->x1 + 1.0f;
  const real box_h = box->y2 - box->y1 + 1.0f;

  if (box_w >= min_w && box_h >= min_h) return 1;
  return 0;
}

#ifdef PASS
typedef struct ProposalOption_
{
  int num_concats;
  real* ratios;
  int num_ratios;
  real* scales;
  int num_scales;
  int base_size;
  int feat_stride;
  int min_size;
  int pre_nms_topn;
  int post_nms_topn;
  real nms_thresh;
} ProposalOption;
#endif

#define MAX_NUM_RATIO_SCALE 10
#define MAX_DATA_WIDTH 80
#define MAX_DATA_HEIGHT 80
#define MAX_NUM_PROPOSAL 6000

void generate_anchors(real* const anchors,
                      const ProposalOption* const option)
{
  const real base_area = option->base_size * option->base_size;
  const real ctr = 0.5f * (option->base_size - 1.0f);
  real wr[MAX_NUM_RATIO_SCALE];
  real hr[MAX_NUM_RATIO_SCALE];
  for (int i = 0; i < option->num_ratios; ++i) {
    wr[i] = round(sqrt(base_area / option->ratios[i]));
    hr[i] = round(wr[i] * option->ratios[i]);
  }

  // anchor generation
  {
    real* p_anchors = anchors;
    for (int c = 0; c < option->num_concats; ++c) {
      for (int i = 0; i < option->num_ratios; ++i) {
        for (int j = 0; j < option->num_scales; ++j) {
          const real ws = 0.5f * (wr[i] * option->scales[j] - 1.0f);
          const real hs = 0.5f * (hr[i] * option->scales[j] - 1.0f);
          p_anchors[0] = ctr - ws;
          p_anchors[1] = ctr - hs;
          p_anchors[2] = ctr + ws;
          p_anchors[3] = ctr + hs;
          p_anchors += 4;
        } // endfor j
      } // endfor i
    } // endfor c
  }
}

void sort_box(BoundingBox* const list, const int start, const int end,
              const int num_top)
{
  int left = start + 1, right = end;
  real pivot_score = list[start].score;
  BoundingBox temp;
  while (left <= right) {
    while (left <= end && list[left].score >= pivot_score) ++left;
    while (right > start && list[right].score <= pivot_score) --right;
    if (left <= right) {
      temp = list[left];
      list[left] = list[right];
      list[right] = temp;
      ++left;
      --right;
    }
  }
  if (right > start) {
    temp = list[right];
    list[right] = list[start];
    list[start] = temp;
  }
  if (start < right - 1) {
    sort_box(list, start, right - 1, num_top);
  }
  if (right + 1 < num_top && right + 1 < end) {
    sort_box(list, right + 1, end, num_top);
  }
}

void forward(const Tensor* const bottom4d,
             const Tensor* const pred_box4d,
             const Tensor* const img_info1d,
             Tensor* const top2d,
             const real* const anchors,
             const ProposalOption* const option)
{
  BoundingBox* const proposals
      = (BoundingBox*)malloc(MAX_NUM_RATIO_SCALE * MAX_NUM_RATIO_SCALE *
                             MAX_DATA_WIDTH * MAX_DATA_HEIGHT * sizeof(BoundingBox));
  real* const sorted_dets = (real*)malloc(MAX_NUM_PROPOSAL * 5 * sizeof(real));
  int* const keep = (int*)malloc(MAX_NUM_PROPOSAL * sizeof(int));

  // bottom4d: N x 2 x num_anchors x H x W
  // pred_box4d: N x num_anchors x 4 x H x W
  // img_info1d: N x 4
  // top2d: N x num_rois x 4
  const real* p_bottom_data = bottom4d->data;
  const real* p_pred_box_data = pred_box4d->data;
  const real* p_img_info = img_info1d->data;
  real* p_top_data = top2d->data;
  const int num_anchors = option->num_concats * option->num_ratios * option->num_scales;
  for (int n = 0; n < bottom4d->num_items; ++n) {
    const int H = bottom4d->shape[n][2];
    const int W = bottom4d->shape[n][3];
    const int HW = H * W;
    const real im_w = p_img_info[1];
    const real im_h = p_img_info[0];
    const real min_w = option->min_size * p_img_info[2];
    const real min_h = option->min_size * p_img_info[3];

    // enumerate all proposals
    int num_proposals = 0;
    for (int h = 0; h < H; ++h) {
      for (int w = 0; w < W; ++w) {
        const real x = w * option->feat_stride;
        const real y = h * option->feat_stride;
        const real* p_box = &p_pred_box_data[h * W + w];
        const real* p_score = &p_bottom_data[num_anchors * HW + h * W + w];
        for (int k = 0; k < num_anchors; ++k) {
          const real dx = p_box[(k * 4 + 0) * HW];
          const real dy = p_box[(k * 4 + 1) * HW];
          const real dw = p_box[(k * 4 + 2) * HW];
          const real dh = p_box[(k * 4 + 3) * HW];
          proposals[num_proposals].x1 = x + anchors[k * 4 + 0];
          proposals[num_proposals].y1 = y + anchors[k * 4 + 1];
          proposals[num_proposals].x2 = x + anchors[k * 4 + 2];
          proposals[num_proposals].y2 = y + anchors[k * 4 + 3];
          proposals[num_proposals].score = p_score[k * HW];
          {
            const int box_created = transform_box(&proposals[num_proposals],
                                                  dx, dy, dw, dh,
                                                  im_w, im_h, min_w, min_h);
            if (box_created) ++num_proposals;
          }
        } // endfor k
      } // endfor w
    } // endfor h

    // choose candidates according to scores
    sort_box(proposals, 0, num_proposals - 1, option->pre_nms_topn);
    if (num_proposals > option->pre_nms_topn) {
      num_proposals = option->pre_nms_topn;
    }
    for (int i = 0; i < num_proposals; ++i) {
      sorted_dets[i * 5 + 0] = proposals[i].x1;
      sorted_dets[i * 5 + 1] = proposals[i].y1;
      sorted_dets[i * 5 + 2] = proposals[i].x2;
      sorted_dets[i * 5 + 3] = proposals[i].y2;
      sorted_dets[i * 5 + 4] = proposals[i].score;
    }

    // roi retrieval
    {
      int num_rois = 0;
      _nms_gpu(keep, &num_rois, sorted_dets, num_proposals, 5, option->nms_thresh);

      if (num_rois > option->post_nms_topn) {
        num_rois = option->post_nms_topn;
      }
      top2d->shape[n][0] = num_rois;
      top2d->shape[n][1] = 4;
      for (int i = 0; i < num_rois; ++i) {
        p_top_data[i * 4 + 0] = proposals[keep[i]].x1;
        p_top_data[i * 4 + 1] = proposals[keep[i]].y1;
        p_top_data[i * 4 + 2] = proposals[keep[i]].x2;
        p_top_data[i * 4 + 3] = proposals[keep[i]].y2;
      }
    }

    // locate next item
    p_top_data += 4 * top2d->shape[n][0];
    p_bottom_data += 2 * num_anchors * HW;
    p_pred_box_data += 4 * num_anchors * HW;
    p_img_info += 4;
  } // endfor num_items

  top2d->ndim = 2;
  top2d->num_items = bottom4d->num_items;

  free(proposals);
  free(sorted_dets);
  free(keep);
}

#include <stdlib.h>

int main(void)
{
  real anchors[100];
  real scales[5] = {3, 6, 9, 16, 32};
  real ratios[5] = {0.5, 0.666, 1.0, 1.5, 2.0};
  ProposalOption option;
  option.num_concats = 3;
  option.base_size = 16;
  option.feat_stride = 16;
  option.pre_nms_topn = 6000;
  option.post_nms_topn = 300;
  option.nms_thresh = 0.7;
  option.min_size = 16;
  option.scales = &scales[0];
  option.ratios = &ratios[0];
  option.num_scales = 5;
  option.num_ratios = 5;
  generate_anchors(anchors, &option);
  int num_anchors = option.num_concats * option.num_scales * option.num_ratios;

  Tensor score, bbox, im_info, roi;
  real score_data[150*36*46], bbox_data[300*36*46], im_info_data[4], roi_data[300*4];
  score.ndim = 4; score.num_items = 1; score.data = &score_data[0];
  for (int i = 0; i < score.num_items; ++i) {
    score.shape[i][0] = 2;
    score.shape[i][1] = num_anchors;
    score.shape[i][2] = 36;
    score.shape[i][3] = 46;
  }
  bbox.ndim = 4; bbox.num_items = score.num_items; bbox.data = &bbox_data[0];
  for (int i = 0; i < bbox.num_items; ++i) {
    bbox.shape[i][0] = num_anchors;
    bbox.shape[i][1] = 4;
    bbox.shape[i][2] = 36;
    bbox.shape[i][3] = 46;
  }
  im_info.ndim = 1; im_info.num_items = score.num_items; im_info.data = &im_info_data[0];
  for (int i = 0; i < im_info.num_items; ++i) {
    im_info.shape[i][0] = 4;
  }
  roi.ndim = 2; roi.num_items = score.num_items; roi.data = &roi_data[0];

  FILE* fp = fopen("../data/temp/proposal_bottom0.txt", "r");
  for (int i = 0; i < flatten_size(&score); ++i)
    fscanf(fp, "%f", &score_data[i]);
  fclose(fp);
  fp = fopen("../data/temp/proposal_bottom1.txt", "r");
  for (int i = 0; i < flatten_size(&bbox); ++i)
    fscanf(fp, "%f", &bbox_data[i]);
  fclose(fp);
  fp = fopen("../data/temp/proposal_bottom2.txt", "r");
  for (int i = 0; i < flatten_size(&im_info); ++i)
    fscanf(fp, "%f", &im_info_data[i]);
  fclose(fp);

  forward(&score, &bbox, &im_info, &roi, anchors, &option);

  real* p_roi_data = roi.data;
  for (int n = 0; n < roi.num_items; ++n) {
    printf("batch %d: %d x %d\n", n, roi.shape[n][0], roi.shape[n][1]);
    for (int i = 0; i < roi.shape[n][0]; ++i) {
      for (int j = 0; j < roi.shape[n][1]; ++j) {
        printf("%.6f ", *(p_roi_data++));
      }
      printf("\n");
    }
  }

  return 0;
}
